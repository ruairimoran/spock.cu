#ifndef TREE_CUH
#define TREE_CUH

#include "../include/gpu.cuh"
#include <fstream>


__global__ void d_populateProbabilities(size_t *anc, real_t *prob, size_t numNodes, real_t *condProb);

__global__ void d_populateChildren(size_t *from, size_t *to, size_t numNonleafNodes, size_t *numChildren);

__global__ void d_populateStages(size_t *stages, size_t numStages, size_t numNodes, size_t *nodeFrom, size_t *nodeTo);


/**
 * Store scenario tree data
 * - from JSON file
 *
 * Note: `d_` indicates a device pointer
 */
class ScenarioTree {

private:
    bool m_isMarkovian = false;  ///< Is tree generated by a stopped Markov process?
    bool m_isIid = false;  ///< Is tree generated by an independent and identically distributed sequence?
    size_t m_numEvents = 0;  ///< Total number of possible events
    size_t m_numNodes = 0;  ///< Total number of nodes (incl. root)
    size_t m_numNonleafNodes = 0;  ///< Total number of nonleaf nodes (incl. root)
    size_t m_numStages = 0;  ///< Total number of stages (incl. root)
    std::unique_ptr<DTensor<size_t>> m_d_stages = nullptr;  ///< Ptr to stage of node at index
    std::unique_ptr<DTensor<size_t>> m_d_ancestors = nullptr;  ///< Ptr to ancestor of node at index
    std::unique_ptr<DTensor<real_t>> m_d_probabilities = nullptr;  ///< Ptr to probability of visiting node at index
    std::unique_ptr<DTensor<real_t>> m_d_conditionalProbabilities = nullptr;  ///< Ptr to conditional probability of visiting node at index
    std::unique_ptr<DTensor<size_t>> m_d_events = nullptr;  ///< Ptr to event occurred that led to node at index
    std::unique_ptr<DTensor<size_t>> m_d_childFrom = nullptr;  ///< Ptr to first child of node at index
    std::unique_ptr<DTensor<size_t>> m_d_childTo = nullptr;  ///< Ptr to last child of node at index
    std::unique_ptr<DTensor<size_t>> m_d_numChildren = nullptr;  ///< Ptr to number of children of node at index
    std::unique_ptr<DTensor<size_t>> m_d_nodeFrom = nullptr;  ///< Ptr to first node of stage at index
    std::unique_ptr<DTensor<size_t>> m_d_nodeTo = nullptr;  ///< Ptr to last node of stage at index
    /* Host data */
    std::unique_ptr<std::vector<size_t>> m_childFrom = nullptr;  ///< Ptr to first node of stage at index
    std::unique_ptr<std::vector<size_t>> m_childTo = nullptr;  ///< Ptr to last node of stage at index
    std::unique_ptr<std::vector<size_t>> m_nodeFrom = nullptr;  ///< Ptr to first node of stage at index
    std::unique_ptr<std::vector<size_t>> m_nodeTo = nullptr;  ///< Ptr to last node of stage at index

public:
    /**
     * Constructor from JSON file stream
     */
    ScenarioTree(std::ifstream &file) {
        std::string json((std::istreambuf_iterator<char>(file)),
                         std::istreambuf_iterator<char>());
        rapidjson::Document doc;
        doc.Parse(json.c_str());

        if (doc.HasParseError()) {
            std::cerr << "Error parsing tree JSON: " << GetParseError_En(doc.GetParseError()) << "\n";
            throw std::invalid_argument("Cannot parse tree JSON file");
        }

        /* Store single element data from JSON in host memory */
        m_isMarkovian = doc["isMarkovian"].GetBool();
        m_isIid = doc["isIid"].GetBool();
        m_numEvents = doc["numEvents"].GetInt();
        m_numNonleafNodes = doc["numNonleafNodes"].GetInt();
        m_numNodes = doc["numNodes"].GetInt();
        m_numStages = doc["numStages"].GetInt();

        /* Allocate memory on host for JSON data */
        std::vector<size_t> hostStages(m_numNodes);
        std::vector<size_t> hostAncestors(m_numNodes);
        std::vector<real_t> hostProbabilities(m_numNodes);
        std::vector<size_t> hostEvents(m_numNodes);
        std::vector<size_t> hostChildrenFrom(m_numNonleafNodes);
        std::vector<size_t> hostChildrenTo(m_numNonleafNodes);

        /* Allocate memory on device */
        m_d_stages = std::make_unique<DTensor<size_t>>(m_numNodes);
        m_d_ancestors = std::make_unique<DTensor<size_t>>(m_numNodes);
        m_d_probabilities = std::make_unique<DTensor<real_t>>(m_numNodes);
        m_d_conditionalProbabilities = std::make_unique<DTensor<real_t>>(m_numNodes);
        m_d_events = std::make_unique<DTensor<size_t>>(m_numNodes);
        m_d_childFrom = std::make_unique<DTensor<size_t>>(m_numNonleafNodes);
        m_d_childTo = std::make_unique<DTensor<size_t>>(m_numNonleafNodes);
        m_d_numChildren = std::make_unique<DTensor<size_t>>(m_numNonleafNodes);
        m_d_nodeFrom = std::make_unique<DTensor<size_t>>(m_numStages);
        m_d_nodeTo = std::make_unique<DTensor<size_t>>(m_numStages);

        /* Store array data from JSON in host memory */
        for (rapidjson::SizeType i = 0; i < m_numNodes; i++) {
            if (i < m_numNonleafNodes) {
                hostChildrenFrom[i] = doc["childrenFrom"][i].GetInt();
                hostChildrenTo[i] = doc["childrenTo"][i].GetInt();
            }
            hostStages[i] = doc["stages"][i].GetInt();
            hostAncestors[i] = doc["ancestors"][i].GetInt();
            hostProbabilities[i] = doc["probabilities"][i].GetDouble();
            hostEvents[i] = doc["events"][i].GetInt();
        }
        ///< Note that anc[0] and events[0] will be max(size_t) on device because they are -1 on host

        /* Transfer JSON array data to device */
        m_d_stages->upload(hostStages);
        m_d_ancestors->upload(hostAncestors);
        m_d_probabilities->upload(hostProbabilities);
        m_d_events->upload(hostEvents);
        m_d_childFrom->upload(hostChildrenFrom);
        m_d_childTo->upload(hostChildrenTo);

        /* Populate remaining arrays on device */
        d_populateProbabilities<<<DIM2BLOCKS(m_numNodes), THREADS_PER_BLOCK>>>(
            m_d_ancestors->raw(), m_d_probabilities->raw(), m_numNodes, m_d_conditionalProbabilities->raw());
        d_populateChildren<<<DIM2BLOCKS(m_numNonleafNodes), THREADS_PER_BLOCK>>>(
            m_d_childFrom->raw(), m_d_childTo->raw(), m_numNonleafNodes, m_d_numChildren->raw());
        d_populateStages<<<DIM2BLOCKS(m_numStages), THREADS_PER_BLOCK>>>(
            m_d_stages->raw(), m_numStages, m_numNodes, m_d_nodeFrom->raw(), m_d_nodeTo->raw());

        /* Download data needed on host */
        m_childFrom = std::make_unique<std::vector<size_t>>(m_d_childFrom->numEl());
        m_d_childFrom->download(*m_childFrom);
        m_childTo = std::make_unique<std::vector<size_t>>(m_d_childTo->numEl());
        m_d_childTo->download(*m_childTo);
        m_nodeFrom = std::make_unique<std::vector<size_t>>(m_d_nodeFrom->numEl());
        m_d_nodeFrom->download(*m_nodeFrom);
        m_nodeTo = std::make_unique<std::vector<size_t>>(m_d_nodeTo->numEl());
        m_d_nodeTo->download(*m_nodeTo);
    }

    /**
     * Destructor
     */
    ~ScenarioTree() {}

    /**
     * Getters
     */
    bool isMarkovian() { return m_isMarkovian; }

    bool isIid() { return m_isIid; }

    size_t numEvents() { return m_numEvents; }

    size_t numNonleafNodes() { return m_numNonleafNodes; }

    size_t numLeafNodes() { return m_numNodes - m_numNonleafNodes; }

    size_t numNodes() { return m_numNodes; }

    size_t numStages() { return m_numStages; }

    DTensor<size_t> &stages() { return *m_d_stages; }

    DTensor<size_t> &ancestors() { return *m_d_ancestors; }

    DTensor<real_t> &probabilities() { return *m_d_probabilities; }

    DTensor<real_t> &conditionalProbabilities() { return *m_d_conditionalProbabilities; }

    DTensor<size_t> &events() { return *m_d_events; }

    DTensor<size_t> &childFrom() { return *m_d_childFrom; }

    DTensor<size_t> &childTo() { return *m_d_childTo; }

    DTensor<size_t> &numChildren() { return *m_d_numChildren; }

    DTensor<size_t> &nodeFrom() { return *m_d_nodeFrom; }

    DTensor<size_t> &nodeTo() { return *m_d_nodeTo; }

    std::unique_ptr<std::vector<size_t>> &childFromHost() { return m_childFrom; }

    std::unique_ptr<std::vector<size_t>> &childToHost() { return m_childTo; }

    std::unique_ptr<std::vector<size_t>> &nodeFromHost() { return m_nodeFrom; }

    std::unique_ptr<std::vector<size_t>> &nodeToHost() { return m_nodeTo; }

    /**
     * Debugging
     */
    void print() {
        std::cout << "Number of events: " << m_numEvents << "\n";
        std::cout << "Number of nonleaf nodes: " << m_numNonleafNodes << "\n";
        std::cout << "Number of nodes: " << m_numNodes << "\n";
        std::cout << "Number of stages: " << m_numStages << "\n";
        printIfTensor("Stages (from device): ", m_d_stages);
        printIfTensor("Ancestors (from device): ", m_d_ancestors);
        printIfTensor("Probabilities (from device): ", m_d_probabilities);
        printIfTensor("Conditional probabilities (from device): ", m_d_conditionalProbabilities);
        printIfTensor("Events (from device): ", m_d_events);
        printIfTensor("Children::from (from device): ", m_d_childFrom);
        printIfTensor("Children::to (from device): ", m_d_childTo);
        printIfTensor("Stage::from (from device): ", m_d_nodeFrom);
        printIfTensor("Stage::to (from device): ", m_d_nodeTo);
    }
};

#endif
