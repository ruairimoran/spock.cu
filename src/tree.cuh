#ifndef TREE_CUH
#define TREE_CUH

#include "../include/gpu.cuh"
#include <fstream>


__global__ void d_populateProbabilities(size_t *anc, real_t *prob, size_t numNodes, real_t *condProb);

__global__ void d_populateChildren(size_t *from, size_t *to, size_t numNonleafNodes, size_t *numChildren);

__global__ void d_populateStages(size_t *stages, size_t numStages, size_t numNodes, size_t *nodeFrom, size_t *nodeTo);


/**
 * Store scenario tree data
 * - from JSON file
 *
 * Note: `d_` indicates a device pointer
 */
class ScenarioTree {

private:
    bool m_isMarkovian = false;  ///< Is tree generated by a stopped Markov process?
    bool m_isIid = false;  ///< Is tree generated by an independent and identically distributed sequence?
    size_t m_numEvents = 0;  ///< Total number of possible events
    size_t m_numNodes = 0;  ///< Total number of nodes (incl. root)
    size_t m_numNonleafNodes = 0;  ///< Total number of nonleaf nodes (incl. root)
    size_t m_numStages = 0;  ///< Total number of stages (incl. root)
    DTensor<size_t> m_d_stages;  ///< Ptr to stage of node at index
    DTensor<size_t> m_d_ancestors;  ///< Ptr to ancestor of node at index
    DTensor<real_t> m_d_probabilities;  ///< Ptr to probability of visiting node at index
    DTensor<real_t> m_d_conditionalProbabilities;  ///< Ptr to conditional probability of visiting node at index
    DTensor<size_t> m_d_events;  ///< Ptr to event occurred that led to node at index
    DTensor<size_t> m_d_childFrom;  ///< Ptr to first child of node at index
    DTensor<size_t> m_d_childTo;  ///< Ptr to last child of node at index
    DTensor<size_t> m_d_numChildren;  ///< Ptr to number of children of node at index
    DTensor<size_t> m_d_nodeFrom;  ///< Ptr to first node of stage at index
    DTensor<size_t> m_d_nodeTo;  ///< Ptr to last node of stage at index

public:
    /**
     * Constructor from JSON file stream
     */
    ScenarioTree(std::ifstream &file) {
        std::string json((std::istreambuf_iterator<char>(file)),
                         std::istreambuf_iterator<char>());
        rapidjson::Document doc;
        doc.Parse(json.c_str());

        if (doc.HasParseError()) {
            std::cerr << "Error parsing tree JSON: " << GetParseError_En(doc.GetParseError()) << std::endl;
            throw std::invalid_argument("Cannot parse tree JSON file");
        }

        /** Store single element data from JSON in host memory */
        m_isMarkovian = doc["isMarkovian"].GetBool();
        m_isIid = doc["isIid"].GetBool();
        m_numEvents = doc["numEvents"].GetInt();
        m_numNonleafNodes = doc["numNonleafNodes"].GetInt();
        m_numNodes = doc["numNodes"].GetInt();
        m_numStages = doc["numStages"].GetInt();

        /** Allocate memory on host for JSON data */
        std::vector<size_t> hostStages(m_numNodes);
        std::vector<size_t> hostAncestors(m_numNodes);
        std::vector<real_t> hostProbabilities(m_numNodes);
        std::vector<size_t> hostEvents(m_numNodes);
        std::vector<size_t> hostChildrenFrom(m_numNonleafNodes);
        std::vector<size_t> hostChildrenTo(m_numNonleafNodes);

        /** Allocate memory on device */
        m_d_stages(m_numNodes);
        m_d_ancestors(m_numNodes);
        m_d_probabilities(m_numNodes);
        m_d_conditionalProbabilities(m_numNodes);
        m_d_events(m_numNodes);
        m_d_childFrom(m_numNonleafNodes);
        m_d_childTo(m_numNonleafNodes);
        m_d_numChildren(m_numNonleafNodes);
        m_d_nodeFrom(m_numStages);
        m_d_nodeTo(m_numStages);

        /** Store array data from JSON in host memory */
        for (rapidjson::SizeType i = 0; i < m_numNodes; i++) {
            if (i < m_numNonleafNodes) {
                hostChildrenFrom[i] = doc["childrenFrom"][i].GetInt();
                hostChildrenTo[i] = doc["childrenTo"][i].GetInt();
            }
            hostStages[i] = doc["stages"][i].GetInt();
            hostAncestors[i] = doc["ancestors"][i].GetInt();
            hostProbabilities[i] = doc["probabilities"][i].GetDouble();
            hostEvents[i] = doc["events"][i].GetInt();
        }
        ///< Note that anc[0] and events[0] will be max(size_t) on device because they are -1 on host

        /** Transfer JSON array data to device */
        m_d_stages.upload(hostStages);
        m_d_ancestors.upload(hostAncestors);
        m_d_probabilities.upload(hostProbabilities);
        m_d_events.upload(hostEvents);
        m_d_childFrom.upload(hostChildrenFrom);
        m_d_childTo.upload(hostChildrenTo);

        /** Populate remaining arrays on device */
        d_populateProbabilities<<<DIM2BLOCKS(m_numNodes), THREADS_PER_BLOCK>>>(
                m_d_ancestors.raw(), m_d_probabilities.raw(), m_numNodes, m_d_conditionalProbabilities.raw());
        d_populateChildren<<<DIM2BLOCKS(m_numNonleafNodes), THREADS_PER_BLOCK>>>(
                m_d_childFrom.raw(), m_d_childTo.raw(), m_numNonleafNodes, m_d_numChildren.raw());
        d_populateStages<<<DIM2BLOCKS(m_numStages), THREADS_PER_BLOCK>>>(
                m_d_stages.raw(), m_numStages, m_numNodes, m_d_nodeFrom.raw(), m_d_nodeTo.raw());
    }

    /**
     * Destructor
     */
    ~ScenarioTree() {}

    /**
     * Getters
     */
    bool isMarkovian() { return m_isMarkovian; }

    bool isIid() { return m_isIid; }

    size_t numEvents() { return m_numEvents; }

    size_t numNonleafNodes() { return m_numNonleafNodes; }

    size_t numLeafNodes() { return m_numNodes - m_numNonleafNodes; }

    size_t numNodes() { return m_numNodes; }

    size_t numStages() { return m_numStages; }

    DTensor<size_t> &stages() { return m_d_stages; }

    DTensor<size_t> &ancestors() { return m_d_ancestors; }

    DTensor<real_t> &probabilities() { return m_d_probabilities; }

    DTensor<real_t> &conditionalProbabilities() { return m_d_conditionalProbabilities; }

    DTensor<size_t> &events() { return m_d_events; }

    DTensor<size_t> &childFrom() { return m_d_childFrom; }

    DTensor<size_t> &childTo() { return m_d_childTo; }

    DTensor<size_t> &numChildren() { return m_d_numChildren; }

    DTensor<size_t> &nodeFrom() { return m_d_nodeFrom; }

    DTensor<size_t> &nodeTo() { return m_d_nodeTo; }

    /**
     * Debugging
     */
    void print() {
        std::vector<size_t> hostDataIntNumNonleafNodes(m_numNonleafNodes);
        std::vector<size_t> hostDataIntNumNodes(m_numNodes);
        std::vector<real_t> hostDataRealNumNodes(m_numNodes);
        std::vector<size_t> hostDataIntNumStages(m_numStages);

        std::cout << "Number of events: " << m_numEvents << std::endl;
        std::cout << "Number of nonleaf nodes: " << m_numNonleafNodes << std::endl;
        std::cout << "Number of nodes: " << m_numNodes << std::endl;
        std::cout << "Number of stages: " << m_numStages << std::endl;

        m_d_stages.download(hostDataIntNumNodes);
        std::cout << "Stages (from device): ";
        for (size_t i = 0; i < m_numNodes; i++) {
            std::cout << hostDataIntNumNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_ancestors.download(hostDataIntNumNodes);
        std::cout << "Ancestors (from device): ";
        for (size_t i = 0; i < m_numNodes; i++) {
            std::cout << hostDataIntNumNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_probabilities.download(hostDataRealNumNodes);
        std::cout << "Probabilities (from device): ";
        for (size_t i = 0; i < m_numNodes; i++) {
            std::cout << hostDataRealNumNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_conditionalProbabilities.download(hostDataRealNumNodes);
        std::cout << "Conditional probabilities (from device): ";
        for (size_t i = 0; i < m_numNodes; i++) {
            std::cout << hostDataRealNumNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_events.download(hostDataIntNumNodes);
        std::cout << "Events (from device): ";
        for (size_t i = 0; i < m_numNodes; i++) {
            std::cout << hostDataIntNumNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_childFrom.download(hostDataIntNumNonleafNodes);
        std::cout << "Children::from (from device): ";
        for (size_t i = 0; i < m_numNonleafNodes; i++) {
            std::cout << hostDataIntNumNonleafNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_childTo.download(hostDataIntNumNonleafNodes);
        std::cout << "Children::to (from device): ";
        for (size_t i = 0; i < m_numNonleafNodes; i++) {
            std::cout << hostDataIntNumNonleafNodes[i] << " ";
        }
        std::cout << std::endl;

        m_d_nodeFrom.download(hostDataIntNumStages);
        std::cout << "Stage::from (from device): ";
        for (size_t i = 0; i < m_numStages; i++) {
            std::cout << hostDataIntNumStages[i] << " ";
        }
        std::cout << std::endl;

        m_d_nodeTo.download(hostDataIntNumStages);
        std::cout << "Stage::to (from device): ";
        for (size_t i = 0; i < m_numStages; i++) {
            std::cout << hostDataIntNumStages[i] << " ";
        }
        std::cout << std::endl;
    }
};

#endif
