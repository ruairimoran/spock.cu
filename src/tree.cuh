#ifndef __TREE__
#define __TREE__
#include "../include/stdgpu.h"
#include <fstream>


__global__ void populateProbabilities(size_t* anc, real_t* prob, size_t numNodes, real_t* condProb);
__global__ void populateChildren(size_t* from, size_t* to, size_t numNonleafNodes, size_t* numChildren);
__global__ void populateStages(size_t* stages, size_t numStages, size_t numNodes, size_t* stageFrom, size_t* stageTo);


/**
 * Store scenario tree data
 * - from JSON file
 *
 * Note: `d_` indicates a device posize_ter
 */
class ScenarioTree {

	private:
        bool m_isMarkovian = false;  ///< Is tree generated by a stopped Markov process?
        bool m_isIid = false;  ///< Is tree generated by an independent and identically distributed sequence?
        size_t m_numEvents = 0;  ///< Total number of possible events
        size_t m_numNodes = 0;  ///< Total number of nodes (incl. root)
        size_t m_numNonleafNodes = 0;  ///< Total number of nonleaf nodes (incl. root)
        size_t m_numStages = 0;  ///< Total number of stages (incl. root)
        DeviceVector<size_t> m_d_stages;  ///< Ptr to stage of node at index
        DeviceVector<size_t> m_d_ancestors;  ///< Ptr to ancestor of node at index
        DeviceVector<real_t> m_d_probabilities;  ///< Ptr to probability of visiting node at index
        DeviceVector<real_t> m_d_conditionalProbabilities;  ///< Ptr to conditional probability of visiting node at index
        DeviceVector<size_t> m_d_events;  ///< Ptr to event occurred that led to node at index
        DeviceVector<size_t> m_d_childFrom;  ///< Ptr to first child of node at index
        DeviceVector<size_t> m_d_childTo;  ///< Ptr to last child of node at index
        DeviceVector<size_t> m_d_numChildren;  ///< Ptr to number of children of node at index
        DeviceVector<size_t> m_d_stageFrom;  ///< Ptr to first node of stage at index
        DeviceVector<size_t> m_d_stageTo;  ///< Ptr to last node of stage at index

	public:
		/**
		 * Constructor from JSON file stream
		 */
		ScenarioTree(std::ifstream& file) {
            std::string json((std::istreambuf_iterator<char>(file)),
                              std::istreambuf_iterator<char>());
            rapidjson::Document doc;
            doc.Parse(json.c_str());

            if (doc.HasParseError()) {
              std::cerr << "Error parsing tree JSON: " << GetParseError_En(doc.GetParseError()) << std::endl;
              throw std::invalid_argument("Cannot parse tree JSON file");
            }

            /** Store single element data from JSON in host memory */
            m_isMarkovian = doc["isMarkovian"].GetBool();
            m_isIid = doc["isIid"].GetBool();
            m_numEvents = doc["numEvents"].GetInt();
            m_numNonleafNodes = doc["numNonleafNodes"].GetInt();
            m_numNodes = doc["numNodes"].GetInt();
            m_numStages = doc["numStages"].GetInt();

            /** Allocate memory on host for JSON data */
            std::vector<size_t> hostStages(m_numNodes);
            std::vector<size_t> hostAncestors(m_numNodes);
            std::vector<real_t> hostProbabilities(m_numNodes);
            std::vector<size_t> hostEvents(m_numNodes);
            std::vector<size_t> hostChildrenFrom(m_numNonleafNodes);
            std::vector<size_t> hostChildrenTo(m_numNonleafNodes);

            /** Allocate memory on device */
            m_d_stages.allocateOnDevice(m_numNodes);
            m_d_ancestors.allocateOnDevice(m_numNodes);
            m_d_probabilities.allocateOnDevice(m_numNodes);
            m_d_conditionalProbabilities.allocateOnDevice(m_numNodes);
            m_d_events.allocateOnDevice(m_numNodes);
            m_d_childFrom.allocateOnDevice(m_numNonleafNodes);
            m_d_childTo.allocateOnDevice(m_numNonleafNodes);
            m_d_numChildren.allocateOnDevice(m_numNonleafNodes);
            m_d_stageFrom.allocateOnDevice(m_numStages);
            m_d_stageTo.allocateOnDevice(m_numStages);

            /** Store array data from JSON in host memory */
            for (rapidjson::SizeType i = 0; i<m_numNodes; i++) {
                if (i < m_numNonleafNodes) {
                    hostChildrenFrom[i] = doc["childrenFrom"][i].GetInt();
                    hostChildrenTo[i] = doc["childrenTo"][i].GetInt();
                }
                hostStages[i] = doc["stages"][i].GetInt();
                hostAncestors[i] = doc["ancestors"][i].GetInt();
                hostProbabilities[i] = doc["probabilities"][i].GetDouble();
                hostEvents[i] = doc["events"][i].GetInt();
            }
            ///< Note that anc[0] and events[0] will be max(size_t) on device because they are -1 on host

            /** Transfer JSON array data to device */
            m_d_stages.upload(hostStages);
            m_d_ancestors.upload(hostAncestors);
            m_d_probabilities.upload(hostProbabilities);
            m_d_events.upload(hostEvents);
            m_d_childFrom.upload(hostChildrenFrom);
            m_d_childTo.upload(hostChildrenTo);

            /** Populate remaining arrays on device */
            populateProbabilities<<<DIM2BLOCKS(m_numNodes), THREADS_PER_BLOCK>>>(
                m_d_ancestors.get(), m_d_probabilities.get(), m_numNodes, m_d_conditionalProbabilities.get());
            populateChildren<<<DIM2BLOCKS(m_numNonleafNodes), THREADS_PER_BLOCK>>>(
                m_d_childFrom.get(), m_d_childTo.get(), m_numNonleafNodes, m_d_numChildren.get());
            populateStages<<<DIM2BLOCKS(m_numStages), THREADS_PER_BLOCK>>>(
                m_d_stages.get(), m_numStages, m_numNodes, m_d_stageFrom.get(), m_d_stageTo.get());
        }

		/**
		 * Destructor
		 */
		~ScenarioTree() {}

        /**
         * Getters
         */
        bool isMarkovian() { return m_isMarkovian; }
        bool isIid() { return m_isIid; }
        size_t numEvents() { return m_numEvents; }
        size_t numNonleafNodes() { return m_numNonleafNodes; }
        size_t numLeafNodes() { return m_numNodes - m_numNonleafNodes; }
        size_t numNodes() { return m_numNodes; }
        size_t numStages() { return m_numStages; }
        DeviceVector<size_t>& stages() { return m_d_stages; }
		DeviceVector<size_t>& ancestors() { return m_d_ancestors; }
        DeviceVector<real_t>& probabilities() { return m_d_probabilities; }
        DeviceVector<real_t>& conditionalProbabilities() { return m_d_conditionalProbabilities; }
        DeviceVector<size_t>& events() { return m_d_events; }
        DeviceVector<size_t>& childFrom() { return m_d_childFrom; }
        DeviceVector<size_t>& childTo() { return m_d_childTo; }
        DeviceVector<size_t>& numChildren() { return m_d_numChildren; }
        DeviceVector<size_t>& stageFrom() { return m_d_stageFrom; }
        DeviceVector<size_t>& stageTo() { return m_d_stageTo; }

        /**
         * Debugging
         */
		void print(){
            std::vector<size_t> hostDataIntNumNonleafNodes(m_numNonleafNodes);
            std::vector<size_t> hostDataIntNumNodes(m_numNodes);
            std::vector<real_t> hostDataRealNumNodes(m_numNodes);
            std::vector<size_t> hostDataIntNumStages(m_numStages);

			std::cout << "Number of events: " << m_numEvents << std::endl;
            std::cout << "Number of nonleaf nodes: " << m_numNonleafNodes << std::endl;
            std::cout << "Number of nodes: " << m_numNodes << std::endl;
            std::cout << "Number of stages: " << m_numStages << std::endl;

            m_d_stages.download(hostDataIntNumNodes);
            std::cout << "Stages (from device): ";
            for (size_t i=0; i<m_numNodes; i++) {
                std::cout << hostDataIntNumNodes[i] << " ";
            }
            std::cout << std::endl;

            m_d_ancestors.download(hostDataIntNumNodes);
			std::cout << "Ancestors (from device): ";
			for (size_t i=0; i<m_numNodes; i++) {
				std::cout << hostDataIntNumNodes[i] << " ";
			}
			std::cout << std::endl;

            m_d_probabilities.download(hostDataRealNumNodes);
            std::cout << "Probabilities (from device): ";
            for (size_t i=0; i<m_numNodes; i++) {
                std::cout << hostDataRealNumNodes[i] << " ";
            }
            std::cout << std::endl;

            m_d_conditionalProbabilities.download(hostDataRealNumNodes);
            std::cout << "Conditional probabilities (from device): ";
            for (size_t i=0; i<m_numNodes; i++) {
                std::cout << hostDataRealNumNodes[i] << " ";
            }
            std::cout << std::endl;

            m_d_events.download(hostDataIntNumNodes);
            std::cout << "Events (from device): ";
            for (size_t i=0; i<m_numNodes; i++) {
                std::cout << hostDataIntNumNodes[i] << " ";
            }
            std::cout << std::endl;

			m_d_childFrom.download(hostDataIntNumNonleafNodes);
			std::cout << "Children::from (from device): ";
			for (size_t i=0; i<m_numNonleafNodes; i++) {
				std::cout << hostDataIntNumNonleafNodes[i] << " ";
			}
			std::cout << std::endl;

			m_d_childTo.download(hostDataIntNumNonleafNodes);
			std::cout << "Children::to (from device): ";
			for (size_t i=0; i<m_numNonleafNodes; i++) {
				std::cout << hostDataIntNumNonleafNodes[i] << " ";
			}
			std::cout << std::endl;

            m_d_stageFrom.download(hostDataIntNumStages);
            std::cout << "Stage::from (from device): ";
            for (size_t i=0; i<m_numStages; i++) {
                std::cout << hostDataIntNumStages[i] << " ";
            }
            std::cout << std::endl;

            m_d_stageTo.download(hostDataIntNumStages);
            std::cout << "Stage::to (from device): ";
            for (size_t i=0; i<m_numStages; i++) {
                std::cout << hostDataIntNumStages[i] << " ";
            }
            std::cout << std::endl;
		}
};

#endif
