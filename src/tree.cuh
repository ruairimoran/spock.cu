#ifndef TREE_CUH
#define TREE_CUH

#include "../include/gpu.cuh"
#include <fstream>


__global__ void d_populateProbabilities(size_t *anc, real_t *prob, size_t numNodes, real_t *condProb);

__global__ void d_populateChildren(size_t *from, size_t *to, size_t numNonleafNodes, size_t *numChildren);

__global__ void d_populateStages(size_t *stages, size_t numStages, size_t numNodes, size_t *nodeFrom, size_t *nodeTo);


/**
 * Store scenario tree data
 * - from JSON file
 *
 * Note: `d_` indicates a device pointer
 */
class ScenarioTree {

private:
    bool m_isMarkovian = false;  ///< Is tree generated by a stopped Markov process?
    bool m_isIid = false;  ///< Is tree generated by an independent and identically distributed sequence?
    size_t m_numEvents = 0;  ///< Total number of possible events
    size_t m_numNodes = 0;  ///< Total number of nodes (incl. root)
    size_t m_numNonleafNodes = 0;  ///< Total number of nonleaf nodes (incl. root)
    size_t m_numStages = 0;  ///< Total number of stages (incl. root)
    DTensor<size_t> m_d_stages;  ///< Ptr to stage of node at index
    DTensor<size_t> m_d_ancestors;  ///< Ptr to ancestor of node at index
    DTensor<real_t> m_d_probabilities;  ///< Ptr to probability of visiting node at index
    DTensor<real_t> m_d_conditionalProbabilities;  ///< Ptr to conditional probability of visiting node at index
    DTensor<size_t> m_d_events;  ///< Ptr to event occurred that led to node at index
    DTensor<size_t> m_d_childFrom;  ///< Ptr to first child of node at index
    DTensor<size_t> m_d_childTo;  ///< Ptr to last child of node at index
    DTensor<size_t> m_d_numChildren;  ///< Ptr to number of children of node at index
    DTensor<size_t> m_d_nodeFrom;  ///< Ptr to first node of stage at index
    DTensor<size_t> m_d_nodeTo;  ///< Ptr to last node of stage at index

public:
    /**
     * Constructor from JSON file stream
     */
    ScenarioTree(std::ifstream &file) {
        std::string json((std::istreambuf_iterator<char>(file)),
                         std::istreambuf_iterator<char>());
        rapidjson::Document doc;
        doc.Parse(json.c_str());

        if (doc.HasParseError()) {
            std::cerr << "Error parsing tree JSON: " << GetParseError_En(doc.GetParseError()) << "\n";
            throw std::invalid_argument("Cannot parse tree JSON file");
        }

        /** Store single element data from JSON in host memory */
        m_isMarkovian = doc["isMarkovian"].GetBool();
        m_isIid = doc["isIid"].GetBool();
        m_numEvents = doc["numEvents"].GetInt();
        m_numNonleafNodes = doc["numNonleafNodes"].GetInt();
        m_numNodes = doc["numNodes"].GetInt();
        m_numStages = doc["numStages"].GetInt();

        /** Allocate memory on host for JSON data */
        std::vector<size_t> hostStages(m_numNodes);
        std::vector<size_t> hostAncestors(m_numNodes);
        std::vector<real_t> hostProbabilities(m_numNodes);
        std::vector<size_t> hostEvents(m_numNodes);
        std::vector<size_t> hostChildrenFrom(m_numNonleafNodes);
        std::vector<size_t> hostChildrenTo(m_numNonleafNodes);

        /** Allocate memory on device */
        DTensor<size_t> d_stages(m_numNodes);
        DTensor<size_t> d_ancestors(m_numNodes);
        DTensor<real_t> d_probabilities(m_numNodes);
        DTensor<real_t> d_conditionalProbabilities(m_numNodes);
        DTensor<size_t> d_events(m_numNodes);
        DTensor<size_t> d_childFrom(m_numNonleafNodes);
        DTensor<size_t> d_childTo(m_numNonleafNodes);
        DTensor<size_t> d_numChildren(m_numNonleafNodes);
        DTensor<size_t> d_nodeFrom(m_numStages);
        DTensor<size_t> d_nodeTo(m_numStages);

        /** Store array data from JSON in host memory */
        for (rapidjson::SizeType i = 0; i < m_numNodes; i++) {
            if (i < m_numNonleafNodes) {
                hostChildrenFrom[i] = doc["childrenFrom"][i].GetInt();
                hostChildrenTo[i] = doc["childrenTo"][i].GetInt();
            }
            hostStages[i] = doc["stages"][i].GetInt();
            hostAncestors[i] = doc["ancestors"][i].GetInt();
            hostProbabilities[i] = doc["probabilities"][i].GetDouble();
            hostEvents[i] = doc["events"][i].GetInt();
        }
        ///< Note that anc[0] and events[0] will be max(size_t) on device because they are -1 on host

        /** Transfer JSON array data to device */
        d_stages.upload(hostStages);
        d_ancestors.upload(hostAncestors);
        d_probabilities.upload(hostProbabilities);
        d_events.upload(hostEvents);
        d_childFrom.upload(hostChildrenFrom);
        d_childTo.upload(hostChildrenTo);

        /** Populate remaining arrays on device */
        d_populateProbabilities<<<DIM2BLOCKS(m_numNodes), THREADS_PER_BLOCK>>>(
                d_ancestors.raw(), d_probabilities.raw(), m_numNodes, d_conditionalProbabilities.raw());
        d_populateChildren<<<DIM2BLOCKS(m_numNonleafNodes), THREADS_PER_BLOCK>>>(
                d_childFrom.raw(), d_childTo.raw(), m_numNonleafNodes, d_numChildren.raw());
        d_populateStages<<<DIM2BLOCKS(m_numStages), THREADS_PER_BLOCK>>>(
                d_stages.raw(), m_numStages, m_numNodes, d_nodeFrom.raw(), d_nodeTo.raw());

        /** Assign tensors to class attribute */
        m_d_stages = d_stages;
        m_d_ancestors = d_ancestors;
        m_d_probabilities = d_probabilities;
        m_d_conditionalProbabilities = d_conditionalProbabilities;
        m_d_events = d_events;
        m_d_childFrom = d_childFrom;
        m_d_childTo = d_childTo;
        m_d_numChildren = d_numChildren;
        m_d_nodeFrom = d_nodeFrom;
        m_d_nodeTo = d_nodeTo;
    }

    /**
     * Destructor
     */
    ~ScenarioTree() {}

    /**
     * Getters
     */
    bool isMarkovian() { return m_isMarkovian; }

    bool isIid() { return m_isIid; }

    size_t numEvents() { return m_numEvents; }

    size_t numNonleafNodes() { return m_numNonleafNodes; }

    size_t numLeafNodes() { return m_numNodes - m_numNonleafNodes; }

    size_t numNodes() { return m_numNodes; }

    size_t numStages() { return m_numStages; }

    DTensor<size_t> &stages() { return m_d_stages; }

    DTensor<size_t> &ancestors() { return m_d_ancestors; }

    DTensor<real_t> &probabilities() { return m_d_probabilities; }

    DTensor<real_t> &conditionalProbabilities() { return m_d_conditionalProbabilities; }

    DTensor<size_t> &events() { return m_d_events; }

    DTensor<size_t> &childFrom() { return m_d_childFrom; }

    DTensor<size_t> &childTo() { return m_d_childTo; }

    DTensor<size_t> &numChildren() { return m_d_numChildren; }

    DTensor<size_t> &nodeFrom() { return m_d_nodeFrom; }

    DTensor<size_t> &nodeTo() { return m_d_nodeTo; }

    /**
     * Debugging
     */
    void print() {
        std::cout << "Number of events: " << m_numEvents << "\n";
        std::cout << "Number of nonleaf nodes: " << m_numNonleafNodes << "\n";
        std::cout << "Number of nodes: " << m_numNodes << "\n";
        std::cout << "Number of stages: " << m_numStages << "\n";
        std::cout << "Stages (from device): " << m_d_stages << "\n";
        std::cout << "Ancestors (from device): " << m_d_ancestors << "\n";
        std::cout << "Probabilities (from device): " << m_d_probabilities << "\n";
        std::cout << "Conditional probabilities (from device): " << m_d_conditionalProbabilities << "\n";
        std::cout << "Events (from device): " << m_d_events << "\n";
        std::cout << "Children::from (from device): " << m_d_childFrom << "\n";
        std::cout << "Children::to (from device): " << m_d_childTo << "\n";
        std::cout << "Stage::from (from device): " << m_d_nodeFrom << "\n";
        std::cout << "Stage::to (from device): " << m_d_nodeTo << "\n";
    }
};

#endif
