#include <stdio.h>
#include <vector>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include "../include/stdgpu.h"
#include "../include/DeviceVector.cuh"


#define gpuErrchk(ans) { gpuAssert((ans), __FILE__, __LINE__); }


inline void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true) {
   if (code != cudaSuccess) {
      fprintf(stderr,"GPUassert: %s %s %d\n", cudaGetErrorString(code), file, line);
      if (abort) exit(code);
   }
}


/**
 * Computing conditional probability of each tree node
 * @param[in] anc device ptr to ancestor of node at index
 * @param[in] prob device ptr to probability of visiting node at index
 * @param[in] numNodes total number of nodes
 * @param[out] condProb device ptr to conditional probability of visiting node at index, given ancestor node visited
 */
__global__ void populateProbabilities(int* anc, real_t* prob, int numNodes, real_t* condProb) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i == 0) {
//        condProb[i] = 1.0;  // ERROR when you manipulate data on device
    } else if (i < numNodes) {
//        condProb[i] = prob[i] / prob[anc[i]];  // ERROR when you manipulate data on device
    }
}


/**
 * Populating stagesFrom and stagesTo
 * @param[in] stages device ptr to stage of node at index
 * @param[in] numStages total number of stages
 * @param[out] stageFrom device ptr to first node of stage at index
 * @param[out] stageTo device ptr to last node of stage at index
 */
__global__ void populateStages(int* stages, int numStages, int numNodes, int* stageFrom, int* stageTo) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < numStages) {
        for (int j=0; j<numNodes; i++) {
            if (stages[j] == i) {
//                stageFrom[i] = j;  // ERROR when you manipulate data on device
                break;
            }
        }
        for (int j=numNodes-1; j>=0; i--) {
            if (stages[j] == i) {
//                stageTo[i] = j;  // ERROR when you manipulate data on device
                break;
            }
        }
    }
}


/**
 * Store scenario tree data
 * - from JSON file
 *
 * Note: `d_` indicates a device pointer
 */
class ScenarioTree {

	private:
        bool m_isMarkovian = false;  ///< Is tree generated by a stopped Markov process?
        bool m_isIid = false;  ///< Is tree generated by an independent and identically distributed sequence?
        size_t m_numNonleafNodes = 0;  ///< Total number of nonleaf nodes (incl. root)
        size_t m_numNodes = 0;  ///< Total number of nodes (incl. root)
        size_t m_numStages = 0;  ///< Total number of stages (incl. root)
        DeviceVector<int> m_d_stages = 0;  ///< Ptr to stage of node at index
        DeviceVector<int> m_d_ancestors = 0;  ///< Ptr to ancestor of node at index
        DeviceVector<real_t> m_d_probabilities = 0;  ///< Ptr to probability of visiting node at index
        DeviceVector<real_t> m_d_conditionalProbabilities = 0;  ///< Ptr to conditional probability of visiting node at index
        DeviceVector<int> m_d_events = 0;  ///< Ptr to event occurred that led to node at index
        DeviceVector<int> m_d_childFrom = 0;  ///< Ptr to first child of node at index
        DeviceVector<int> m_d_childTo = 0;  ///< Ptr to last child of node at index
        DeviceVector<int> m_d_stageFrom = 0;  ///< Ptr to first node of stage at index
        DeviceVector<int> m_d_stageTo = 0;  ///< Ptr to last node of stage at index

	public:
		/**
		 * Constructor from JSON file stream
		 */
		ScenarioTree(std::ifstream& file) {
            std::string json((std::istreambuf_iterator<char>(file)),
                              std::istreambuf_iterator<char>());
            rapidjson::Document doc;
            doc.Parse(json.c_str());

            if (doc.HasParseError()) {
              std::cerr << "Error parsing JSON: " << GetParseError_En(doc.GetParseError()) << std::endl;
              throw std::invalid_argument("Cannot parse JSON file");
            }

            m_isMarkovian = doc["isMarkovian"].GetBool();
            m_isIid = doc["isIid"].GetBool();
            m_numNonleafNodes = doc["numNonleafNodes"].GetInt();
            m_numNodes = doc["numNodes"].GetInt();
            m_numStages = doc["numStages"].GetInt();

            /** Convert JSON data to vectors */
            std::vector<int> vecStages(m_numNodes);
            std::vector<int> vecAncestors(m_numNodes);
            std::vector<real_t> vecProbabilities(m_numNodes);
            std::vector<int> vecEvents(m_numNodes);
            std::vector<int> vecChildrenFrom(m_numNonleafNodes);
            std::vector<int> vecChildrenTo(m_numNonleafNodes);
            for (rapidjson::SizeType i = 0; i<m_numNodes; i++) {
                if (i < m_numNonleafNodes) {
                    vecChildrenFrom[i] = doc["childrenFrom"][i].GetInt();
                    vecChildrenTo[i] = doc["childrenTo"][i].GetInt();
                }
                vecStages[i] = doc["stages"][i].GetInt();
                vecAncestors[i] = doc["ancestors"][i].GetInt();
                vecProbabilities[i] = doc["probabilities"][i].GetDouble();
                vecEvents[i] = doc["events"][i].GetInt();
            }

            /** Transfer data to device
             * CAUSING MEMCHECK ERRORS **********************************************************************
             */
            m_d_stages.upload(vecStages);
            m_d_ancestors.upload(vecAncestors);
            m_d_probabilities.upload(vecProbabilities);
            m_d_events.upload(vecEvents);
            m_d_childFrom.upload(vecChildrenFrom);
            m_d_childTo.upload(vecChildrenTo);

            /** Populate remaining arrays on device */
            populateProbabilities<<<m_numNodes, 1>>>(m_d_ancestors.get(), m_d_probabilities.get(), m_numNodes,
                                                     m_d_conditionalProbabilities.get());
            populateStages<<<m_numNodes, 1>>>(m_d_stages.get(), m_numStages, m_numNodes,
                                              m_d_stageFrom.get(), m_d_stageTo.get());
        }

		/**
		 * Destructor
		 */
		~ScenarioTree() {}

        /**
         * Getters
         */
        bool isMarkovian() { return m_isMarkovian; }
        bool isIid() { return m_isIid; }
        int numNonleafNodes() { return m_numNonleafNodes; }
        int numNodes() { return m_numNodes; }
        int numStages() { return m_numStages; }
        DeviceVector<int> stages() { return m_d_stages; }
		DeviceVector<int> ancestors() { return m_d_ancestors; }
        DeviceVector<real_t> probabilities() { return m_d_probabilities; }
        DeviceVector<real_t> conditionalProbabilities() { return m_d_conditionalProbabilities; }
        DeviceVector<int> events() { return m_d_events; }
        DeviceVector<int> childFrom() { return m_d_childFrom; }
        DeviceVector<int> childTo() { return m_d_childTo; }
        DeviceVector<int> stageFrom() { return m_d_stageFrom; }
        DeviceVector<int> stageTo() { return m_d_stageTo; }

        /**
         * Debugging
         */
		void print(){
            int *hostNodeDataNonleaf = new int[m_numNonleafNodes];
            int *hostNodeDataNodes = new int[m_numNodes];
			std::cout << "Number of ancestors: " << m_numNodes << std::endl;
            m_d_ancestors.download(hostNodeDataNodes);
			std::cout << "Ancestors (from device): ";
			for (size_t i=0; i<m_numNodes; i++) {
				std::cout << hostNodeDataNodes[i] << " ";
			}
			std::cout << std::endl;

			m_d_stages.download(hostNodeDataNodes);
			std::cout << "Stages (from device): ";
			for (size_t i=0; i<m_numNodes; i++) {
				std::cout << hostNodeDataNodes[i] << " ";
			}
			std::cout << std::endl;

			m_d_childFrom.download(hostNodeDataNonleaf);
			std::cout << "Children::from (from device): ";
			for (size_t i=0; i<m_numNonleafNodes; i++) {
				std::cout << hostNodeDataNonleaf[i] << " ";
			}
			std::cout << std::endl;

			m_d_childTo.download(hostNodeDataNonleaf);
			std::cout << "Children::to (from device): ";
			for (size_t i=0; i<m_numNonleafNodes; i++) {
				std::cout << hostNodeDataNonleaf[i] << " ";
			}
			std::cout << std::endl;
		}
};
